# Exploit DNS
[![Python3.x](https://img.shields.io/badge/python-3.x-FADA5E.svg?logo=python)](https://www.python.org/) [![PEP8](https://img.shields.io/badge/code%20style-pep8-red.svg)](https://www.python.org/dev/peps/pep-0008/)

Eploit-DNS tool is a highly configurable DNS proxy for Penetration Testing. It is capable of the fine configuration of which DNS replies to modify or to simply proxy with real responses. In order to take advantage of the tool, you must either manually configure or poison DNS server entry to point to a fake DNS server. **This tool requires root privileges to run on privileged ports.**

## Setting up a DNS Proxy

Before you can start using DNSChef, you must configure your machine to use a DNS nameserver with the tool running on it. You have several options based on the operating system you are going to use:

* **Linux** Edit /etc/resolv.conf to include a line on the very top with your traffic analysis host (e.g add “nameserver 127.0.0.1” if you are running locally). Alternatively, you can add a DNS server address using tools such as Network Manager. Inside the Network Manager open IPv4 Settings, select Automatic (DHCP) addresses only or Manual from the Method drop-down box, and edit DNS Servers text box to include an IP address with DNS running.

* **Mac OS** Open System Preferences and click on the Network icon. Select the active interface and fill in the DNS Server field. If you are using Airport then you will have to click on Advanced… button and edit DNS servers from there. Alternatively, you can edit /etc/resolv.conf and add a fake nameserver to the very top there (e.g “nameserver 127.0.0.1”).

* **Windows** Select Network Connections from the Control Panel. Next select one of the connections (e.g. “Local Area Connection”), right-click on it and select properties. From within a newly appearing dialog box, select Internet Protocol (TCP/IP) and click on properties. At last select Use the following DNS server addresses radio button and enter the IP address with DNS running. For example, if running locally enter 127.0.0.1.

### Disclaimer
- This tool is only for testing and educational purposes and can only be used where strict consent has been given. Do not use it for illegal purposes! It is the end user’s responsibility to obey all applicable local, state and federal laws. I am not responsible for any misuse or damage caused by this tool.

## Installation

```
git clone https://github.com/CyberCommands/Exploit-DNS.git
```
```
cd Exploit-DNS/
```
```
sudo pip install -r requirements.txt
```
```
sudo python3 exp-dns.py --help
```

### Usage:

This guide will concentrate on Unix environments; however, all of the examples below were tested to work on Windows as well.

Let's get a taste of `exp-dns.py` with its most basic monitoring functionality. Execute the following command as root (required to start a server on port 53):

```
./exp-dns.py
```

Without any parameters, `exp-dns.py` will run in full proxy mode. This means that all requests will simply be forwarded to an upstream DNS server (8.8.8.8 by default) and returned back to the querying host. For example, let’s query an “A” record for a domain:

```
    $ host -t A example.org
```

Eploit-dns will print the following logline showing the time, source IP address, type of record requested, and most importantly which name was queried.

This mode is useful for simple application monitoring where you need to figure out which domains it uses for its communications.

Now, that you know how to start Exploit-dns, let's configure it to fake all replies to point to 127.0.0.1 using the *--fakeip* parameter

```
./exp-dns.py --fakeip 127.0.0.1 -q
```

In the output, you can see that `exp-dns.py` was configured to proxy all requests to 127.0.0.1. The first line of a log at 08:11:23 shows that we have "cooked" the "A" record response to point to 127.0.0.1. However, further requests for 'AAAA' and 'MX' records are simply proxied from a real DNS server. Let's see the output from requesting program:

```
    $ host google.com localhost
```

As you can see the program was tricked to use 127.0.0.1 for the IPv4 address. However, the information obtained from IPv6 (AAAA) and mail (MX) records appear completely legitimate. The goal of `exp-dns.py` is to have the least impact on the correct operation of the program, so if an application relies on a specific mail server it will correctly obtain one through this proxied request.

Let's fake one more request to illustrate how to target multiple records at the same time:

```
./exp-dns.py --fakeip 127.0.0.1 --fakeipv6 ::1 -q
```

In addition to the --fakeip flag, I have now specified --fakeipv6 designed to fake 'AAAA' record queries. Here is an updated program output:

```
    $ host google.com localhost
```

**NOTE:** For usability, not all DNS record types are exposed on the command line. Additional records such as PTR, TXT, SOA, etc. can be specified using the --file flag and an appropriate record header. See the external definitions file section below for details.

At last, let's observe how the application handles queries of type ANY:

```
./exp-dns.py --fakeip 127.0.0.1 --fakeipv6 ::1 --fakemail mail.fake.com --fakealias www.fake.com --fakens ns.fake.com -q
```

DNS ANY record queries results in `exp-dns.py` returning every faked record that it knows about for an applicable domain. Here is the output that the program will see:

```
$host -t ANY google.com localhost
```

Using the above example, consider you only want to intercept requests for *example.org* and leave queries to all other domains such as *webfaction.com* without modification. You can use the *--fakedomains* parameter as illustrated below:

```
./exp-dns.py --fakeip 127.0.0.1 --fakedomains example.org -q
```

From the above example the request for *example.org* was faked; however, the request for *mx9.webfaction.com* was left alone. Filtering domains is very useful when you attempt to isolate a single application without breaking the rest.

NOTE: `exp-dns.py` will not verify whether the domain exists or not before faking the response. If you have specified a domain it will always resolve to a fake value whether it really exists or not.

From the above example the request for *example.org* was faked; however, the request for *mx9.webfaction.com* was left alone. Filtering domains is very useful when you attempt to isolate a single application without breaking the rest.

NOTE: `exp-dns.py` will not verify whether the domain exists or not before faking the response. If you have specified a domain it will always resolve to a fake value whether it really exists or not.

In another situation you may need to fake responses for all requests except a defined list of domains. You can accomplish this task using the *--truedomains* parameter as follows:

```
./exp-dns.py --fakeip 127.0.0.1 --truedomains thesprawl.org,*.webfaction.com -q
```

There are several things going on in the above example. First notice the use of a wildcard (*). All domains matching *.webfaction.com will be reverse matched and resolved to their true values. The request for 'google.com' returned 127.0.0.1 because it was not on the list of excluded domains.

There may be situations where defining a single fake DNS record for all matching domains may not be sufficient. You can use an external file with a collection of DOMAIN=RECORD pairs defining exactly where you want the request to go. For example, let create the following definitions file and call it *dnsconf.ini*

Notice the section header [A], it defines the record type to `exp-dns.py`. Now let's carefully observe the output of multiple queries:

```
./exp-dns.py --file dnschef.ini -q
```

You can mix and match input from a file and command line. For example the following command uses both *--file* and *--fakedomains* parameters:

```
./exp-dns.py --file dnschef.ini --fakeip 6.6.6.6 --fakedomains=example.org,slashdot.org -q
```

For security reasons, `exp-dns.py` listens on a local 127.0.0.1 (or ::1 for IPv6) interface by default. You can make `exp-dns.py` listen on another interface using the *--interface* parameter:

```
./exp-dns.py --interface 0.0.0.0 -q
```

By default, `exp-dns.py` uses Google's public DNS server to make proxy requests. However, you can define a custom list of nameservers using the *--nameservers* parameter:

```
./exp-dns.py --nameservers 4.2.2.1,4.2.2.2 -q
```

It is possible to specify non-standard nameserver port using IP#PORT notation:

```
./exp-dns.py --nameservers 192.0.2.2#5353 -q
```

At the same time it is possible to start `exp-dns.py` itself on an alternative port using the *-p port#* parameter:

```
./exp-dns.py -p 5353 -q
```

DNS protocol can be used over UDP (default) or TCP. `exp-dns.py` implements a TCP mode which can be activated with the *--tcp* flag.

Enjoy the tool

Happy hacking!
